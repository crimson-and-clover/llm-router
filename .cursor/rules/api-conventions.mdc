---
description: API development conventions and best practices
globs: "src/api/**/*.py"
alwaysApply: false
---

# API 开发约定

## 路由组织

- 使用 `APIRouter` 组织相关端点
- 在 `main.py` 中统一注册，添加版本前缀

```python
# src/api/routes_chat.py
from fastapi import APIRouter

router = APIRouter()

@router.post("/chat/completions")
async def chat_completions(req: Request):
    ...

# src/main.py
from src.api.routes_chat import router as chat_router

app.include_router(chat_router, prefix="/api/v1")
```

## 错误响应

使用统一的 JSON 错误格式：

```python
from fastapi.responses import JSONResponse

# 认证失败
return JSONResponse(status_code=401, content={"error": "Unauthorized"})

# 模型未找到
return JSONResponse(status_code=404, content={"error": "Model not found"})

# 请求格式错误
return JSONResponse(status_code=400, content={"error": "Invalid Body"})
```

## 请求验证

```python
@router.post("/chat/completions")
async def chat_completions(req: Request):
    # 1. 解析请求体
    try:
        body = await req.json()
    except:
        return JSONResponse(status_code=400, content={"error": "Invalid Body"})
    
    # 2. 验证认证
    authorization = req.headers.get("Authorization")
    if not authorization:
        return JSONResponse(status_code=401, content={"error": "Unauthorized"})
    
    # 3. 业务逻辑
    ...
```

## Provider 模式

模型名称格式：`provider/model_name`

```python
model = body.get("model")  # e.g., "kimi/k2"
provider_name = model.split("/")[0]    # "kimi"
real_model_name = model.split("/")[1]  # "k2"

# 从 app.state 获取 provider 实例
provider = req.app.state.providers.get(provider_name)
```

## Pipeline 模式

- 使用 Pipeline 处理请求前处理和后处理
- 支持不同用途（如 cursor）的定制逻辑

```python
purpose = query_result.get("purpose", "default")
if purpose == "cursor":
    pipeline = CursorPipeline()
else:
    pipeline = BasePipeline()

# 预处理
payload = pipeline.preprocess_request(ctx, body)

# 后处理
data = pipeline.postprocess_response(ctx, data)
```

## 流式响应

```python
from fastapi.responses import StreamingResponse

async def stream_generator():
    raw_iter = provider.chat_completions_stream(payload)
    async for line in pipeline.rewrite_sse_lines(ctx, raw_iter):
        yield line.encode() + "\n\n".encode()

return StreamingResponse(
    stream_generator(), 
    media_type="text/event-stream"
)
```
